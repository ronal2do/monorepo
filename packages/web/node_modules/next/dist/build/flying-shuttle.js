"use strict";exports.__esModule=true;exports.FlyingShuttle=void 0;var _asyncSema=require("async-sema");var _crypto=_interopRequireDefault(require("crypto"));var _fs=_interopRequireDefault(require("fs"));var _mkdirp=_interopRequireDefault(require("mkdirp"));var _constants=require("next-server/constants");var _os=require("os");var _path=_interopRequireDefault(require("path"));var _util=require("util");var _recursiveDelete=require("../lib/recursive-delete");var Log=_interopRequireWildcard(require("./output/log"));function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}else{var newObj={};if(obj!=null){for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):{};if(desc.get||desc.set){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}}newObj.default=obj;return newObj;}}function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}const FILE_BUILD_ID='HEAD_BUILD_ID';const FILE_UPDATED_AT='UPDATED_AT';const DIR_FILES_NAME='files';const MAX_SHUTTLES=3;const mkdirp=(0,_util.promisify)(_mkdirp.default);const fsExists=(0,_util.promisify)(_fs.default.exists);const fsReadFile=(0,_util.promisify)(_fs.default.readFile);const fsWriteFile=(0,_util.promisify)(_fs.default.writeFile);const fsCopyFile=(0,_util.promisify)(_fs.default.copyFile);const fsReadDir=(0,_util.promisify)(_fs.default.readdir);const fsLstat=(0,_util.promisify)(_fs.default.lstat);async function findCachedShuttles(apexShuttleDirectory){return(await Promise.all((await fsReadDir(apexShuttleDirectory).then(shuttleFiles=>shuttleFiles.map(async f=>({file:f,stats:await fsLstat(_path.default.join(apexShuttleDirectory,f))})))))).filter(({stats})=>stats.isDirectory()).map(({file})=>file);}async function pruneShuttles(apexShuttleDirectory){const allShuttles=await findCachedShuttles(apexShuttleDirectory);if(allShuttles.length<=MAX_SHUTTLES){return;}const datedShuttles=[];for(const shuttleId of allShuttles){const shuttleDirectory=_path.default.join(apexShuttleDirectory,shuttleId);const updatedAtPath=_path.default.join(shuttleDirectory,FILE_UPDATED_AT);let updatedAt;try{updatedAt=new Date((await fsReadFile(updatedAtPath,'utf8')).trim());}catch(err){if(err.code==='ENOENT'){await(0,_recursiveDelete.recursiveDelete)(shuttleDirectory);continue;}throw err;}datedShuttles.push({updatedAt,shuttleDirectory});}const sortedShuttles=datedShuttles.sort((a,b)=>Math.sign(b.updatedAt.valueOf()-a.updatedAt.valueOf()));let prunedShuttles=0;while(sortedShuttles.length>MAX_SHUTTLES){const shuttleDirectory=sortedShuttles.pop();await(0,_recursiveDelete.recursiveDelete)(shuttleDirectory.shuttleDirectory);++prunedShuttles;}if(prunedShuttles){Log.info(`decommissioned ${prunedShuttles} old shuttle${prunedShuttles>1?'s':''}`);}}function isShuttleValid({manifestPath,pagesDirectory,parentCacheIdentifier}){const manifest=require(manifestPath);const{sharedFiles,hashes}=manifest;if(!sharedFiles){return false;}return!sharedFiles.map(file=>{const filePath=_path.default.join(_path.default.dirname(pagesDirectory),file);const exists=_fs.default.existsSync(filePath);if(!exists){return true;}const hash=_crypto.default.createHash('sha1').update(parentCacheIdentifier).update(_fs.default.readFileSync(filePath)).digest('hex');return hash!==hashes[file];}).some(Boolean);}class FlyingShuttle{constructor({buildId,pagesDirectory,distDirectory,cacheIdentifier}){this.apexShuttleDirectory=void 0;this.flyingShuttleId=void 0;this.buildId=void 0;this.pagesDirectory=void 0;this.distDirectory=void 0;this.parentCacheIdentifier=void 0;this._shuttleBuildId=void 0;this._restoreSema=new _asyncSema.Sema(1);this._recalledManifest={sharedFiles:[],pages:{},pageChunks:{},chunks:{},hashes:{}};this.findShuttleId=async()=>{const shuttles=await findCachedShuttles(this.apexShuttleDirectory);return shuttles.find(shuttleId=>{try{const manifestPath=_path.default.join(this.apexShuttleDirectory,shuttleId,_constants.CHUNK_GRAPH_MANIFEST);return isShuttleValid({manifestPath,pagesDirectory:this.pagesDirectory,parentCacheIdentifier:this.parentCacheIdentifier});}catch(_){}return false;});};this.hasShuttle=async()=>{const existingFlyingShuttleId=await this.findShuttleId();this.flyingShuttleId=existingFlyingShuttleId||this.flyingShuttleId;const found=this.shuttleBuildId&&(await fsExists(_path.default.join(this.shuttleDirectory,_constants.CHUNK_GRAPH_MANIFEST)));if(found){Log.info('flying shuttle is docked');}return found;};this.getPageInfos=async()=>{const pageInfos=new Map();const pagesManifest=JSON.parse((await fsReadFile(_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,'serverless/pages-manifest.json'),'utf8')));Object.keys(pagesManifest).forEach(pg=>{const path=pagesManifest[pg];const isStatic=path.endsWith('html');let isAmp=Boolean(pagesManifest[pg+'.amp']);if(pg==='/')isAmp=Boolean(pagesManifest['/index.amp']);pageInfos.set(pg,{isAmp,size:0,static:isStatic,serverBundle:path});});return pageInfos;};this.getUnchangedPages=async()=>{const manifestPath=_path.default.join(this.shuttleDirectory,_constants.CHUNK_GRAPH_MANIFEST);const manifest=require(manifestPath);const{sharedFiles,pages:pageFileDictionary,hashes}=manifest;const pageNames=Object.keys(pageFileDictionary);const allFiles=new Set(sharedFiles);pageNames.forEach(pageName=>pageFileDictionary[pageName].forEach(file=>allFiles.add(file)));const fileChanged=new Map();await Promise.all([...allFiles].map(async file=>{const filePath=_path.default.join(_path.default.dirname(this.pagesDirectory),file);const exists=await fsExists(filePath);if(!exists){fileChanged.set(file,true);return;}const hash=_crypto.default.createHash('sha1').update(this.parentCacheIdentifier).update((await fsReadFile(filePath))).digest('hex');fileChanged.set(file,hash!==hashes[file]);}));const unchangedPages=(sharedFiles||[]).map(f=>fileChanged.get(f)).some(Boolean)?[]:pageNames.filter(p=>!pageFileDictionary[p].map(f=>fileChanged.get(f)).some(Boolean)).filter(pageName=>pageName!=='/_app'&&pageName!=='/_error'&&pageName!=='/_document');if(unchangedPages.length){const u=unchangedPages.length;const c=pageNames.length-u;Log.info(`found ${c} changed and ${u} unchanged page${u>1?'s':''}`);}else{Log.warn(`flying shuttle is going to perform a full rebuild due to changes across all pages`);}return unchangedPages;};this.mergePagesManifest=async()=>{const savedPagesManifest=_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,'serverless/pages-manifest.json');if(!(await fsExists(savedPagesManifest)))return;const saved=JSON.parse((await fsReadFile(savedPagesManifest,'utf8')));const currentPagesManifest=_path.default.join(this.distDirectory,'serverless/pages-manifest.json');const current=JSON.parse((await fsReadFile(currentPagesManifest,'utf8')));await fsWriteFile(currentPagesManifest,JSON.stringify({...saved,...current}));};this.restorePage=async(page,pageInfo={})=>{await this._restoreSema.acquire();try{const manifestPath=_path.default.join(this.shuttleDirectory,_constants.CHUNK_GRAPH_MANIFEST);const manifest=require(manifestPath);const{pages,pageChunks,hashes}=manifest;if(!(pages.hasOwnProperty(page)&&pageChunks.hasOwnProperty(page))){Log.warn(`unable to find ${page} in shuttle`);return false;}const serverless=_path.default.join('serverless/pages',`${page==='/'?'index':page}.${pageInfo.static?'html':'js'}`);const files=[serverless,...pageChunks[page]];const filesExists=await Promise.all(files.map(f=>_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,f)).map(f=>fsExists(f)));if(!filesExists.every(Boolean)){Log.warn(`unable to locate files for ${page} in shuttle`);return false;}const rewriteRegex=new RegExp(`${this.shuttleBuildId}[\\/\\\\]`);const movedPageChunks=[];await Promise.all(files.map(async recallFileName=>{if(!rewriteRegex.test(recallFileName)){const recallPath=_path.default.join(this.distDirectory,recallFileName);const recallPathExists=await fsExists(recallPath);if(!recallPathExists){await mkdirp(_path.default.dirname(recallPath));await fsCopyFile(_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,recallFileName),recallPath);}movedPageChunks.push(recallFileName);return;}const newFileName=recallFileName.replace(rewriteRegex,`${this.buildId}/`);const recallPath=_path.default.join(this.distDirectory,newFileName);const recallPathExists=await fsExists(recallPath);if(!recallPathExists){await mkdirp(_path.default.dirname(recallPath));await fsCopyFile(_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,recallFileName),recallPath);}movedPageChunks.push(newFileName);}));this._recalledManifest.pages[page]=pages[page];this._recalledManifest.pageChunks[page]=movedPageChunks.filter(f=>f!==serverless);this._recalledManifest.hashes=Object.assign({},this._recalledManifest.hashes,pages[page].reduce((acc,cur)=>Object.assign(acc,{[cur]:hashes[cur]}),{}));return true;}finally{this._restoreSema.release();}};this.save=async(staticPages,pageInfos)=>{Log.wait('docking flying shuttle');await(0,_recursiveDelete.recursiveDelete)(this.shuttleDirectory);await mkdirp(this.shuttleDirectory);const nextManifestPath=_path.default.join(this.distDirectory,_constants.CHUNK_GRAPH_MANIFEST);if(!(await fsExists(nextManifestPath))){Log.warn('could not find shuttle payload :: shuttle will not be docked');return;}const nextManifest=JSON.parse((await fsReadFile(nextManifestPath,'utf8')));const storeManifest={// Intentionally does not merge with the recalled manifest
sharedFiles:nextManifest.sharedFiles,pages:Object.assign({},this._recalledManifest.pages,nextManifest.pages),pageChunks:Object.assign({},this._recalledManifest.pageChunks,nextManifest.pageChunks),chunks:Object.assign({},this._recalledManifest.chunks,nextManifest.chunks),hashes:Object.assign({},this._recalledManifest.hashes,nextManifest.hashes)};await fsWriteFile(_path.default.join(this.shuttleDirectory,FILE_BUILD_ID),this.buildId);await fsWriteFile(_path.default.join(this.shuttleDirectory,FILE_UPDATED_AT),new Date().toISOString());const usedChunks=new Set();const pages=Object.keys(storeManifest.pageChunks);pages.forEach(page=>{const info=pageInfos.get(page)||{};storeManifest.pageChunks[page].forEach((file,idx)=>{if(info.isAmp){// AMP pages don't have client bundles
storeManifest.pageChunks[page]=[];return;}usedChunks.add(file);});usedChunks.add(_path.default.join('serverless/pages',`${page==='/'?'index':page}.${staticPages.has(page)?'html':'js'}`));const ampPage=(page==='/'?'/index':page)+'.amp';if(staticPages.has(ampPage)){storeManifest.pages[ampPage]=[];storeManifest.pageChunks[ampPage]=[];usedChunks.add(_path.default.join('serverless/pages',`${ampPage}.html`));}});await fsWriteFile(_path.default.join(this.shuttleDirectory,_constants.CHUNK_GRAPH_MANIFEST),JSON.stringify(storeManifest,null,2)+_os.EOL);await Promise.all([...usedChunks].map(async usedChunk=>{const target=_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,usedChunk);await mkdirp(_path.default.dirname(target));return fsCopyFile(_path.default.join(this.distDirectory,usedChunk),target);}));await fsCopyFile(_path.default.join(this.distDirectory,'serverless/pages-manifest.json'),_path.default.join(this.shuttleDirectory,DIR_FILES_NAME,'serverless/pages-manifest.json'));Log.info(`flying shuttle payload: ${usedChunks.size+2} files`);Log.ready('flying shuttle docked');try{await pruneShuttles(this.apexShuttleDirectory);}catch(e){Log.error('failed to prune old shuttles: '+e);}};_mkdirp.default.sync(this.apexShuttleDirectory=_path.default.join(distDirectory,'cache','next-flying-shuttle'));this.flyingShuttleId=_crypto.default.randomBytes(16).toString('hex');this.buildId=buildId;this.pagesDirectory=pagesDirectory;this.distDirectory=distDirectory;this.parentCacheIdentifier=cacheIdentifier;}get shuttleDirectory(){return _path.default.join(this.apexShuttleDirectory,this.flyingShuttleId);}get shuttleBuildId(){if(this._shuttleBuildId){return this._shuttleBuildId;}const headBuildIdPath=_path.default.join(this.shuttleDirectory,FILE_BUILD_ID);if(!_fs.default.existsSync(headBuildIdPath)){return this._shuttleBuildId=undefined;}const contents=_fs.default.readFileSync(headBuildIdPath,'utf8').trim();return this._shuttleBuildId=contents;}}exports.FlyingShuttle=FlyingShuttle;